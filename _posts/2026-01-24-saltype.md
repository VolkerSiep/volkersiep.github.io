---
layout: post
title:  "Saltype"
subtitle: "A symbolic linear algebra type in python - a brief comparison with sympy and CasADi."
date:   2026-01-24 23:00:00 +0100
categories: [python, repository, numeric]
featured: true
---
# History
Already around 2001, using <i>C++</i>, my PhD student colleague and me sought a library that can efficiently
differentiate numerical code at runtime. There were tools around to generate source code that computed the derivatives
of the original code, then to be linked into the same project.

We were however looking for a tool that derived at runtime, such as

```python
y = sin(x)
z = derive(y, x)  # z would be cos(x), analytically derived
```

Our aim was to work with thermodynamic state functions and be able to obtain arbitrary derivatives for the task at hand.

Early attempts of creating such functionality were cumbersome and inefficient, but eventually the code became more
performant. 

# Saltype concept
Much later, around 2014, after some prototyping, I developed the first versions of today's [Saltype].
Actually, the first catchy name for this was *sympy*, but as it turns out, another project with that name was growing fast
and becoming so famous that also I became aware of it. [sympy] has a much wider scope, but is too slow for the purpose
of generating larger amounts of derivatives. 

[Saltype] is a light-weight symbolic algebra datatype and implemented in pure python.
The following small example shows how first a symbolic variable `x` is defined. Then, a dependent variable `y` is defined,
before we calculate the derivative `dy_dx`. 

```python
from saltype import Leaf
from saltype.tools import Derivative

x = Leaf(3.0)
y = 3 * x ** 2 + 2 * x + 1

dy_dx = Derivative([y], [x])[0, 0]
print(dy_dx.value)  # = 6 * x + 2 = 20
```

The datatype supports reevaluation of the dependent variables after updating the independent ones. Further, one can
use the library to dump the expressions, for instance in `C`.

# Recent developments
I stalled a bit in developing [Saltype] further, but maintain the repository here: [Saltype on github].
The reason for the stalling is that [CasADi] admittingly outperforms [Saltype] by factor five in speed, and it is
more memory-efficient. 

As such, I based the implementation of [SigmaMu] on [CasADi], though the approach is different and required substantial
re-design from its predecessor. The biggest difference is in the internal representation of the statements, and 
consequently that [CasADi] requires to define function objects before any evaluation can be done, and the function
signatures must be defined explicitly. Using [Saltype], the code would look a bit simpler.

# Conclusion
[sympy] is a complete *CAS* (computer algebra system), featuring manipulations of expressions, integrations,
substitutions, and - as one feature - derivatives. Creating large amounts of derivatives, such as Jacobian matrices of
systems with several thousand variables, is very slow.

[CasADi] is a high performant library that delivers derivatives of large systems efficiently and organized in sparse
data structures. This is a good basis for a wide range of root finding, numerical integration, and optimization tasks.

[Saltype] can enjoy a little niche, where a lightweight pure python package with few dependencies is preferred over
high-end performance. One might also argue that the learning curve is not as steep as with [CasADi] or [sympy] - though
documentation enables an efficient start for using either of the packages.



[CasADi]: https://web.casadi.org/
[Saltype]: https://saltype.readthedocs.io/en/latest/index.html
[Saltype on github]: https://github.com/VolkerSiep/saltype
[Saltype-pypi]: https://pypi.org/project/saltype/
[sympy]: https://www.sympy.org/en/index.html
[SigmaMu]: https://sigmamu.readthedocs.io/en/latest/